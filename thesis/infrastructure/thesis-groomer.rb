#!/usr/bin/ruby
####################
# %file 	= 	thesis-groomer.rb
# %author	=	John Haltiwanger
# %project	=	
#	Grammars of Process: 
#		Agency, Collective Becoming, and the Organization of Software
#
# 	A project-specific piece of Ruby programming to augment the files
# 	passed into, and generated by, pandoc. In order to for, instance fix 
#	the issue of section headers (see the section on workflow constraints
#	in the thesis for which this code was developed).

#$:.unshift( File.dirname(__FILE__) )
#require 'groom'
#include Groom

md_file = ARGV[0] # the name of the markdown file is passed in as the only argument.

# Set solme variables to be passed to pandoc
abstract = <<eos
Despite years of theorization, a concise definition of what constitutes a medium remains elusive. Theorists have variously described media as extensions of human senses (Marshall McLuhan), as agents of reform ruled by a double-logic of remediation (Jay David Bolter and Robert Grusin), as aggregates of material specificity (N. Katherine Hayles), and as evolutionarily selected forms defined by their effects (Lev Manovich). While all of these theorists use examples of and from specific media, none of them explicitly address the specificities of media themselves. This thesis proposes viewing media through an {\\em analytics of becoming} in an attempt to address this slipperiness that has resulted from unclear definitions of the concept---a slipperiness that only intensifies within the context of the computer metamedium. Media are seen as reflexive sites in which humans create grammars that organize and distribute processes. As reflexive sites, they both change and are changed by human beings. The reflexiveness of the computer metamedium, defined as it is by its programmability, inspires an investigation into the dynamic and co-evolving relationship between the human and the digital. The practice of {\\em generative design} is selected as an evocative instance of this relationship, and a reflexive engagement with the practice is undertaken as the thesis becomes a site of generative typesetting. Undergoing this practice-based approach leads to complications with existing theorizations of media and also allows for the articulation of free, libre, and open source software as a reflexive site of agency for collective change. The concept of process utilized here is organized according to Gilbert Simondon's theory of {\\em ontogenesis}, a framework that questions \\quote{becoming} rather than \\quote{being} and in so doing provides a mechanism for explaining collective change.
eos

subtitle = "Agency, Collective Becoming, and the Organization of Software"
keywords = "media theory, generative design, FLoSS, ontogenesis, individuation, process oriented perspective, typesetting"

in_code = false

input = File.new("#{md_file}", 'r')
basename = File.basename(md_file, '.md')
html = File.new("#{basename}-html.md", 'w')
context = File.new("#{basename}-context.md", 'w')

first_chapter = true

special_sections = ["Introduction", "Acknowledgments", "Bibliography"]

exclaims = Array.new
questions = Array.new

input.each do |line|
	# !ALWAYS! remember that regex.match() needs parentheses!
	# Set toggle if we are in a code block
	if /^~+~$/.match(line)
		in_code = (in_code == false) ? true : false
		html.puts line
		context.puts line	
	elsif m = /^\#+\s([\S\s]+)\s\#+$/.match(line) and in_code == false
		unless (special_sections & [m[1]]).empty? == true
			html.puts line
			context.puts line
		else
			html.puts "\##{line.chomp}\#"
			context.puts line
		end
	elsif /^\(\%grrrquote\)$/.match(line) and in_code == false
		html.puts '<blockquote>'
		context.puts '\startlongquote'
	elsif /^\/\(\%grrrquote\)$/.match(line) and in_code == false
		html.puts '</blockquote>'
		context.puts '\stoplongquote'
	# Chapter handling (may need to add something to remove the first </div> in a file)
	elsif m = /^\\chapter\{(.+)\}$/.match(line) and in_code == false 
#		html.puts "</div><div class='chapter'>\n# #{m[1]} #"
		html.puts "# #{m[1]} #"
		if first_chapter == true
			context.puts '\stopfrontmatter'
			context.puts line
			first_chapter = false
		else
			context.puts line
		end
	elsif m = /^\\section\{(.+)\}$/.match(line) and in_code == false
		html.puts "## #{m[1]} ##"
		context.puts line
	elsif m = /^\\subsection\{(.+)\}$/.match(line) and in_code == false
		html.puts "### #{m[1]} ###"
		context.puts line
	# Count exclamation mark(up)s
	elsif m = /\(\!+(.+)\!\)/.match(line) 
		exclaims << [$., m[1]] # $. is a special constant for the current line
		html.puts line
		context.puts line
		next
	# Count question mark(up)s
	elsif m = /\(\?+(.+)\?\)/.match(line)
		questions << [$., m[1]]
		html.puts line
		context.puts line
		next
# Small-caps for abbreviations turned out to be do-able but ugly in our case
#	elsif m = /\b([A-Z][A-Z0-9]{2,})\b/.match(line)
#		html.puts line.gsub(m[1], "<abbr>#{m[1]}</abbr>")
#		context.puts line.gsub(m[1], "\\cap{#{m[1]}}")
	else
		html.puts line
		context.puts line
	end
end
html.close
context.close


puts "Grooming successful \t\t\t\t\t ...... \t[OK]"

print "\n### (! * !) ###\n"
puts "What's all this ruckus about, then?"
exclaims.each do |e|
	print "\n\t#{e[1]}\t on line #{e[0]}\n"
end

print "\n### (? * ?) ###\n"
puts "You are asking questions, aren't you?"
questions.each do |q|
	print "\n\t#{q[1]}\ton line #{q[0]}\n"
end
	
puts "\n\n### Conversions happening in sequence ###"
print "Converting #{basename}-html.md to #{basename}.html\t.....\t "
command = Thread.new do
	%x[pandoc -o #{basename}.html --template=/home/serk17/.pandoc/templates/thesis-template.html -s -N -V abstract=\"#{abstract}\" -V subtitle=\"#{subtitle}\" -V keywords=\"#{keywords}\" --toc #{basename}-html.md]
end
command.join
puts "[OK]"

print "Converting #{basename}-context.md to #{basename}.tex\t.....\t "
command = Thread.new do
	%x[pandoc -o #{basename}.tex --template=/home/serk17/.pandoc/templates/thesis-template.context -t context -s -N -V abstract=\"#{abstract}\" -V subtitle=\"#{subtitle}\" -V keywords=\"#{keywords}\" #{basename}-context.md]
end
command.join
puts "[OK]"

puts "Final grooming applied to #{basename}.tex..."


tex = File.new("#{basename}.tex",'r')
groom = File.new("#{basename}-groomed.tex", 'w')
tex.each do |line|
	if m = /\b(ConTeXt|TeX)\b/.match(line)
		groom.puts line.gsub(m[1], "{\\#{m[1].upcase}}")
#	elsif m = /\b(TeX)\b/.match(line)
#		groom.puts line.gsub(m[1], '\cap{\TEX}')
	elsif /^\\section\{Introduction\}$/.match(line) and in_code == false
#		html.puts "<div class='chapter' id='introduction'># Introduction #"
		groom.puts '\intro{Introduction}'
	elsif /^\\section\{Bibliography\}$/.match(line) and in_code == false
#		html.puts "</div><div class='chapter' id='bibliography'># Bibliography #"
#		groom.puts '\startappendices'
#		groom.puts '\appendix{thesis-groomer.rb}'
#		groom.put  '\switchtobodyfont[10pt]'
#		groom.puts '\typeRUBY[]{/home/serk17/.scripts/thesis-groomer.rb}'
#		groom.puts '\stopappendices'
#		groom.puts '\page[odd]'
		groom.puts '\startworkscited'
	elsif /^\\section\{Acknowledgments\}$/.match(line) and in_code == false
#		html.puts "<div class='chapter' id='acknowledgments'>\n# Acknowledgments #"
		groom.puts '\startfrontmatter' 
		groom.puts '\intro{Acknowledgments}'
#	elsif /\\from/.match(line)
#		groom.puts line.gsub('\from','\hyphenatedurl')
	elsif /\\placefigure/.match(line)
		groom.puts line.gsub('\placefigure[here,nonumber]', '\placefigure[here]')
	else
		groom.puts line
	end
end
groom.close


#	if /# Introduction #/.match(line) and in_code == false
#		html.puts "<div class='chapter' id='introduction'># Introduction #"
#		context.puts '\intro{Introduction}'
#	elsif /# Bibliography #/.match(line) and in_code == false
#		html.puts "</div><div class='chapter' id='bibliography'># Bibliography #"
#		context.puts '\startworkscited'
#	elsif /# Acknowledgments #/.match(line) and in_code == false
#		html.puts "<div class='chapter' id='acknowledgments'>\n# Acknowledgments #"
#		context.puts '\startfrontmatter' 
#		context.puts '\intro{Acknowledgments}'


print "Converting #{basename}.tex to #{basename}.pdf\t ..... \t "
command = Thread.new do
	%x[context #{basename}-groomed]
end
command.join
puts "[OK]"

command = Thread.new do
	%x[mv #{basename}-groomed.pdf #{basename}.pdf]
end
command.join
